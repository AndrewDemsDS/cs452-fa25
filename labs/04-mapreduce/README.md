# Lab: Introduction to MapReduce

In this lab tutorial, you'll get a brief introduction to writing programs using MapReduce.

## Prerequisites

### Setting up the Experiment Environment in Cloudlab

For this tutorial, you will be using a CloudLab profile that comes with the latest version of Go. 

Start a new experiment on CloudLab using the `multi-node-cluster` profile in the `UCY-COAST-TEACH` project, configured with a single physical machine node. 

Open a remote SSH terminal session to `node0`.

Verify that the profile has a working installation of Go by typing the following command:

```
$ go version
```

Confirm that the command prints the installed version of Go. If you don't have Go installed then just follow the [download and install](https://go.dev/doc/install) steps.

## MapReduce

MapReduce is a programming model for processing large datasets using a distributed algorithm on a cluster. 

It involves two main steps:
- **Map**: A function that processes input data and produces key/value pairs.
- **Reduce**: A function that aggregates values associated with the same key.

In this lab, we’ll use a simplified, sequential implementation of MapReduce in Go provided in `04-mapreduce/starter`.

The application directory structure follows the [Standard Go Project Layout](https://github.com/golang-standards/project-layout). It's not an official standard defined by the core Go dev team; however, it is a set of common historical and emerging project layout patterns in the Go ecosystem. 
- `/cmd`: Contains the main application for this project. The directory name for each application matches the name of the executable we want to have. In our case, the directory name is `wordcount` and `invertedindex`.
- `/internal`: Contains the private application and library code. This is the code you don't want others importing in their applications or libraries. In our case, it contains the code of the mapreduce implementation. 
- `/test`: Contains external test apps and test data. In our case, it includes the documents that are used as input during development or when running tests.

## Word Count

For this part, you will be implementing word count, a simple and classic Map/Reduce example. Specifically, your task is to modify `mapF` and `reduceF` within `cmd/wordcount/main.go` so that the application reports the number of occurrences of each word. A word is any contiguous sequence of letters, as determined by `unicode.IsLetter`.

There are some input files with pathnames of the form `pg-*.txt` in the `test` directory, downloaded from [Project Gutenberg](https://www.gutenberg.org/). This is the result when you initially try to compile the code we provide you and run it:

```bash
$ go run cmd/wordcount/main.go master sequential test/data/pg-*.txt
# command-line-arguments
./cmd/wordcount/main.go:16: missing return at end of function
./cmd/wordcount/main.go:23: missing return at end of function
```

The compilation fails because we haven't written a complete map function (`mapF()`) nor a complete reduce function (`reduceF()`) in `main.go` yet. 

#### Map Function
The `mapF()` function will be passed the name of a file, as well as that file's contents; it should split it into words, and return a Go slice of key/value pairs, of type `mapreduce.KeyValue`. 

```
Input: (filename, contents)

Output: [(word1, "1"), (word2, "1"), …]
```

#### Reduce Function
The `reduceF()` function will be called once for each key, with a slice of all the values generated by `mapF()` for that key; it should return a single output value.

```
Input: (word, list of "1" strings)

Output: (word, total_count_as_string)
```

#### Testing

You can test your solution using:

```bash
$ go run cmd/wordcount/main.go master sequential test/data/pg-*.txt
master: Starting Map/Reduce task wcseq
Merge: read mrtmp.wcseq-res-0
Merge: read mrtmp.wcseq-res-1
Merge: read mrtmp.wcseq-res-2
master: Map/Reduce task completed
```

The output will be in the file `mrtmp.wcseq`. You can test your implementation's correctness with the following command, which should produce the following top 10 words:

```bash
$ sort -n -k2 mrtmp.wcseq | tail -10
he: 34077
was: 37044
that: 37495
I: 44502
in: 46092
a: 60558
to: 74357
of: 79727
and: 93990
the: 154024
```

You can remove the output file and all intermediate files with:

```
$ rm mrtmp.*
```

To make testing easy for you, from the project directory, run:

```bash
$ sh ./test/scripts/test-wc.sh
and it will report if your solution is correct or not.
```

## Inverted Index

Word count is a classical example of a Map/Reduce application, but it is not an application that many large consumers of Map/Reduce use. It is simply not very often you need to count the words in a really large dataset. For this application exercise, you will instead have you build Map and Reduce functions for generating an inverted index.

Inverted indices are widely used in computer science, and are particularly useful in document searching. Broadly speaking, an inverted index is a map from interesting facts about the underlying data, to the original location of that data. For example, in the context of search, it might be a map from keywords to documents that contain those words.

We have created a second binary in `cmd/invertedindex/main.go` that is very similar to the `cmd/wordcount/main.go` you built earlier. You should modify `mapF` and `reduceF` in `cmd/invertedindex/main.go` so that they together produce an inverted index. 

#### Map Function

The `mapF` function processes each document and generates a list of (word, filename) pairs. For every word in the document, emit a pair with the word as the key and the document name as the value. Normalize words (e.g., convert to uppercase or lowercase) to ensure consistency.

```
Input: (filename, contents)

Output: [(word1, filename), (word2, filename), …]
```

#### Reduce Function

The `reduceF` function receives a word and a list of all document names in which that word appeared. Its job is to produce a single string containing the number of documents followed by the filenames in sorted, comma-separated order.

```
Input: (word, list of filenames)

Output: (word, "#documents file1,file2,…")
```

#### Note on duplicates

You need to ensure that each document is counted only once per word in the final output. How you handle duplicates is flexible: you can remove duplicates either in the map function (emitting each word once per document) or in the reduce function (filtering the list of filenames). Both approaches are valid as long as the final index reflects unique documents for each word.

#### Testing

Running `cmd/invertedindex/main.go` should output a list of tuples, one per line, in the following format. 

```
$ go run `cmd/invertedindex/main.go master sequential test/data/pg-*.txt`
$ head -n5 mrtmp.iiseq
A: 16 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-metamorphosis.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
ABC: 2 pg-les_miserables.txt,pg-war_and_peace.txt
ABOUT: 2 pg-moby_dick.txt,pg-tom_sawyer.txt
ABRAHAM: 1 pg-dracula.txt
ABSOLUTE: 1 pg-les_miserables.txt
```

If it is not clear from the listing above, the format is:

```
word: #documents documents,sorted,and,separated,by,commas
```

You can test your implementation's correctness with the following command, which should produce these resulting last 10 items in the index:

```
sort -k1,1 mrtmp.iiseq | sort -snk2,2 mrtmp.iiseq | grep -v '16' | tail -10
women: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-metamorphosis.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
won: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-metamorphosis.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
wonderful: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
words: 15 pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-metamorphosis.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
worked: 15 pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-metamorphosis.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
worse: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
wounded: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
yes: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-metamorphosis.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
younger: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
yours: 15 pg-being_ernest.txt,pg-dorian_gray.txt,pg-dracula.txt,pg-emma.txt,pg-frankenstein.txt,pg-great_expectations.txt,pg-grimm.txt,pg-huckleberry_finn.txt,pg-les_miserables.txt,pg-moby_dick.txt,pg-sherlock_holmes.txt,pg-tale_of_two_cities.txt,pg-tom_sawyer.txt,pg-ulysses.txt,pg-war_and_peace.txt
```

(this sample result is also found in test/scripts/test-ii.out)

To make testing easy for you, from the project directory, run:

```
$ sh ./test/scripts/test-ii.sh
```

and it will report if your solution is correct or not.